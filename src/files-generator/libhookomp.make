# This make is only to generate the libhookomp.so after generate hookomp.o
# It's automatically executed when all files are generated by the command python3 worker.py

CC=gcc
CXX=g++
LIB_HOOKOMP_PATH=$(PWD)

all: clean info libhookomp

# Step 1: Compiling with Position Independent Code
hookomp.o: $(DIR_OUTPUT)hookomp.c
	${CXX} $(OPTIONS) -c -Werror -fpic $(DIR_OUTPUT)hookomp.c -o $(DIR_OUTPUT)hookomp.o
	# ${CXX} $(OPTIONS) -c -Werror -Wno-write-strings -fpic prepostfunctions.c

# Step 2: Creating a shared library from an object file
libhookomp: hookomp.o
	LD_LIBRARY_PATH=$(PWD):$(LD_LIBRARY_PATH) export LD_LIBRARY_PATH
	${CXX} -L ${LIB_HOOKOMP_PATH} -shared $(DIR_OUTPUT)hookomp.o -ldl -o $(DIR_OUTPUT)libhookomp.so

# Step 3: Linking with a shared library
# As you can see, that was actually pretty easy. We have a shared library. 
# Let’s compile our main.c and link it with libfoo. We’ll call our final program “test.” 
# Note that the -lfoo option is not looking for foo.o, but libfoo.so. GCC assumes that all 
# libraries start with ‘lib’ and end with .so or .a (.so is for shared object or shared 
# libraries, and .a is for archive, or statically linked libraries).

clean:
	rm -rf output/*.o output/main-test output/*.so 

info:
	@echo "Use make OPTIONS=\"-DVERBOSE -DDEBUG\" to compile with messages."